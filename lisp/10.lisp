(ql:quickload "split-sequence")
(defun parse-data (data-lines)
    ; data-lines
    (let ((split-lines (split-sequence:split-sequence-if (lambda (line) (equalp '"" line)) data-lines)))
        (list
            (mapcar (lambda (rule) (mapcar #'parse-integer (uiop:split-string rule :separator "|"))) (first split-lines))
            (mapcar (lambda (reprint) (mapcar #'parse-integer (uiop:split-string reprint :separator ","))) (second split-lines))
        )
    )
)
(defun rule-applies (rule reprint)
    (every #'identity (mapcar (lambda (rule-elem) (find rule-elem reprint :test #'equalp)) rule))
)
(defun passes-rule (rule reprint)
    (< (position (first rule) reprint :from-end T :test #'equalp) (position (second rule) reprint :test #'equalp))
)
(defun follows-rules (rules reprint)
    (every (lambda (rule) (or (not (rule-applies rule reprint)) (passes-rule rule reprint))) rules)
)
(defun middle (reprint)
    (elt reprint (/ (- (length reprint) 1) 2))
)
(defun fix (rules reprint)
    (loop
        (dolist (rule rules)
            (setf reprint (stable-sort reprint (lambda (a b) (and (rule-applies rule (list a b)) (passes-rule rule (list a b))))))
        )
        (when (follows-rules rules reprint) (return reprint))
    )
)
(print
    (if (= 0 (length (uiop:command-line-arguments)))
        '"Usage: script <dat-file>"
        (let ((data (parse-data (uiop:read-file-lines (first (uiop:command-line-arguments))))))
            (let ((rules (first data)) (reprints (second data)))
                (apply #'+ (mapcar #'middle (mapcar (lambda (reprint) (fix rules reprint))
                    (remove-if (lambda (reprint) (follows-rules rules reprint)) reprints)
                )))
            )
        )
    )
)
